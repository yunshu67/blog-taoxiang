<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSS notes</title>
    <style>
        body{
            font-family: "微软雅黑";
            width: 100%;
        }

        code{display: inline-block;
            background-color: #F8F8F8;
            width: 95%;
            box-sizing: border-box;
            margin: 0 1%;
            padding: 1em 1em;

            white-space: pre-line;
            font-size: 10px;
            color: #c7254e;
            border-radius: 4px;
            text-overflow: ellipsis;

        }

        h3{
            padding: 0;
            margin: 0;
        }
        p{
            white-space: pre-line;
            font-size: 10px;
        }
        .title{
            text-align: center;
            height: 50px;
        }
        .content{
            text-align: center;
        }
        .card{
            width: 450px;
            border: 1px solid  black;
            margin-left: 10px;
            display: inline-block;
            vertical-align: top;

        }
        .card .card_title{
            text-align: center;
            font-weight: 900;
            font-size: 20px;
            border-bottom: 1px solid black;
            line-height: 50px;
        }

        .card .card_content{
            padding-left: 5px;
            text-align: left;
        }
        .card .card_content div{
            white-space: pre-line;
            font-size: 10px;
        }
        .card:nth-of-type(2){
            display: none;
        }




    </style>
</head>








<body>
<div class="title"><h1>CSS Notes By Tao</h1></div>
<div class="content">
    <div class="card">
        <div class="card_title">1. 文字属性缩写</div>
        <div class="card_content">
            <p>缩写格式:
                font: style weight size family;
                例如:
                font:italic bold 10px "楷体";

                注意点:
                1.在这种缩写格式中有的属性值可以省略
                sytle可以省略
                weight可以省略
                2.在这种缩写格式中style和weight的位置可以交换
                3.在这种缩写格式中有的属性值是不可以省略的
                size不能省略
                family不能省略
                4.size和family的位置是不能顺便乱放的
                size一定要写在family的前面, 而且size和family必须写在所有属性的最后</p>
        </div>
    </div>

<!--        template: -->
        <div class="card">
            <div class="card_title"></div>
            <div class="card_content">
                <p>

                </p>

            </div>
        </div>


        <div class="card">
            <div class="card_title">2. 文本属性</div>
            <div class="card_content">
                <p>1.文本装饰的属性
                    格式:text-decoration: underline;
                    取值:
                    underline 下划线
                    line-through 删除线
                    overline 上划线
                    none 什么都没有, 最常见的用途就是用于去掉超链接的下划线
                    快捷键:
                    td  text-decoration: none;
                    tdu text-decoration: underline;
                    tdl text-decoration: line-through;
                    tdo text-decoration: overline;

                    2.文本水平对齐的属性
                    格式: text-align: right;
                    取值:
                    left 左
                    right 右
                    center 中
                    快捷键
                    ta text-align: left;
                    tar text-align: right;
                    tac text-align: center;

                    3.文本缩进的属性
                    格式: text-indent: 2em;
                    取值:
                    2em, 其中em是单位, 一个em代表缩进一个文字的宽度
                    快捷键
                    ti text-indent:;
                    ti2e text-indent: 2em;

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">3. 颜色属性</div>
            <div class="card_content">
                <p>1.在CSS中如何通过color属性来修改文字颜色
                    格式: color: 值;
                    取值:
                    1.1英文单词
                    一般情况下常见的颜色都有对应的英文单词, 但是英文单词能够表达的颜色是有限制的, 也就是说不是所有的颜色都能够通过英文单词来表达

                    1.2rgb
                    rgb其实就是三原色, 其中r(red 红色) g(green 绿色) b(blue 蓝色)
                    格式: rgb(0,0,0)
                    那么这个格式中的
                    第一个数字就是用来设置三原色的光源元件红色显示的亮度
                    第二个数字就是用来设置三原色的光源元件绿色显示的亮度
                    第三个数字就是用来设置三原色的光源元件蓝色显示的亮度
                    这其中的每一个数字它的取值是0-255之前, 0代表不发光, 255代表发光, 值越大就越亮

                    红色: rgb(255,0,0);
                    绿色: rgb(0,255,0);
                    蓝色: rgb(0,0,255);
                    黑色: rgb(0,0,0);
                    白色: rgb(255,255,255);

                    在前端开发中其实并不常用黑色
                    只要让红色/绿色/蓝色的值都一样就是灰色
                    而且如果这三个值越小那么就越偏黑色, 越大就越偏白色
                    例如: color: rgb(200,200,200);

                    1.3rgba
                    rgba中的rgb和前面讲解的一样, 只不过多了一个a
                    那么这个a呢代表透明度, 取值是0-1, 取值越小就越透明
                    例如: color: rgba(255,0,0,0.2);

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">4. 标签选择器</div>
            <div class="card_content">
                <p>1.什么是标签选择器?
                    作用: 根据指定的标签名称, 在当前界面中找到所有该名称的标签, 然后设置属性

                    格式:
                    标签名称{
                    属性:值;
                    }

                    注意点:
                    1.标签选择器选中的是当前界面中所有的标签, 而不能单独选中某一个标签
                    2.标签选择器无论标签藏得多深都能选中
                    3.只要是HTML中的标签就可以作为标签选择器(h/a/img/ul/ol/dl/input....)

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">5. id选择器</div>
            <div class="card_content">
                <p>1.什么是id选择器?
                    作用: 根据指定的id名称找到对应的标签, 然后设置属性

                    格式:
                    #id名称{
                    属性:值;
                    }

                    注意点:
                    1.每个HTML标签都有一个属性叫做id, 也就是说每个标签都可以设置id
                    2.在同一个界面中id的名称是不可以重复的
                    3.在编写id选择器时一定要在id名称前面加上#
                    4.id的名称是有一定的规范的
                    4.1id的名称只能由字母/数字/下划线
                    a-z 0-9 _
                    4.2id名称不能以数字开头
                    4.3id名称不能是HTML标签的名称
                    不能是a h1 img input ...
                    5.在企业开发中一般情况下如果仅仅是为了设置样式, 我们不会使用id ,因为在前端开发中id是留给js使用的

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">6. 类选择器</div>
            <div class="card_content">
                <p>1.什么是类选择器?
                    作用: 根据指定的类名称找到对应的标签, 然后设置属性

                    格式:
                    .类名{
                    属性:值;
                    }

                    注意点:
                    1.每个HTML标签都有一个属性叫做class, 也就是说每个标签都可以设置类名
                    2.在同一个界面中class的名称是可以重复的
                    3.在编写class选择器时一定要在class名称前面加上.
                    4.类名的命名规范和id名称的命名规范一样
                    5.类名就是专门用来给CSS设置样式的
                    6.在HTML中每个标签可以同时绑定多个类名
                    格式:
                    《标签名称 class="类名1 类名2 ..."》
                        错误的写法:
                《p class="para1" class="para2"》

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">7. id选择器和class选择器</div>
            <div class="card_content">
                <p>1.id和class的区别?
                    1.1
                    id相当于人的身份证不可以重复
                    class相当于人的名称可以重复
                    1.2
                    一个HTML标签只能绑定一个id名称
                    一个HTML标签可以绑定多个class名称

                    2.id选择器和class选择器区别?
                    id选择器是以#开头
                    class选择器是以.开头

                    3.在企业开发中到底用id选择器还是用class选择器?
                    id一般情况下是给js使用的, 所以除非特殊情况, 否则不要使用id去设置样式

                    4.在企业开发中一个开发人员对类的使用可以看出这个开发人员的技术水平
                    一般情况下在企业开发中要注重冗余代码的抽取, 可以将一些公共的代码抽取到一个类选择器中, 然后让标签和这个类选择器绑定即可

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">8. 后代选择器</div>
            <div class="card_content">
                <p>1.什么是后代选择器?
                    作用: 找到指定标签的所有特定的后代标签, 设置属性

                    格式:
                    标签名称1 标签名称2{
                    属性:值;
                    }
                    先找到所有名称叫做"标签名称1"的标签, 然后再在这个标签下面去查找所有名称叫做"标签名称2"的标签, 然后在设置属性
                    div p{}

                    注意点:
                    1.后代选择器必须用空格隔开
                    2.后代不仅仅是儿子, 也包括孙子/重孙子, 只要最终是放到指定标签中的都是后代
                    3.后代选择器不仅仅可以使用标签名称, 还可以使用其它选择器
                    4.后代选择器可以通过空格一直延续下去
                    <code>

                            /*
                            div p{
                                color: red;
                            }
                            */
                            /*
                            #identity p{
                                color: red;
                            }
                            */
                            /*
                            .para p{
                                color: blue;
                            }
                            */
                            /*
                            #identity #iii{
                                color: skyblue;
                            }
                            */
                            /*
                            #identity .ccc{
                                color: purple;
                            }
                            */
                            div ul li p{
                                color: red;
                            }
                </code>

                </p>
            </div>
        </div>

        <div class="card">
            <div class="card_title">9. 子元素选择器</div>
            <div class="card_content">
                <p>1.什么是子元素选择器?
                    作用: 找到指定标签中所有特定的直接子元素, 然后设置属性

                    格式:
                    标签名称1>标签名称2{
                    属性:值;
                    }
                    先找到所有名称叫做"标签名称1"的标签, 然后在这个标签中查找所有直接子元素名称叫做"标签名称2"的元素

                    注意点:
                    1.子元素选择器只会查找儿子, 不会查找其他被嵌套的标签
                    2.子元素选择器之间需要用>符号连接, 并且不能有空格
                    3.子元素选择器不仅仅可以使用标签名称, 还可以使用其它选择器
                    4.子元素选择器可以通过>符号一直延续下去
                    <code>
                        /*
                        div>p{
                        color: red;
                        }
                        */
                        /*
                        #identity>p{
                        color: blue;
                        }
                        */
                        div>ul>li>p{
                        color: purple;
                        }
                    </code>
                </p>
            </div>
        </div>

    <div class="card">
        <div class="card_title">10. 后代选择器和子元素选择器</div>
        <div class="card_content">
            <p>1.后代选择器和子元素选择器之间的区别?
                1.1
                后代选择器使用空格作为连接符号
                子元素选择器使用>作为连接符号
                1.2
                后代选择器会选中指定标签中, 所有的特定后代标签, 也就是会选中儿子/孙子..., 只要是被放到指定标签中的特定标签都会被选中
                子元素选择器只会选中指定标签中, 所有的特定的直接标签, 也就是只会选中特定的儿子标签

                2.后代选择器和子元素选择器之间的共同点
                2.1
                后代选择器和子元素选择器都可以使用标签名称/id名称/class名称来作为选择器
                2.2
                后代选择器和子元素选择器都可以通过各自的连接符号一直延续下去
                选择器1>选择器2>选择器3>选择器4{}

                3.在企业开发中如何选择
                如果想选中指定标签中的所有特定的标签, 那么就使用后代选择器
                如果只想选中指定标签中的所有特定儿子标签, 那么就使用子元素选择器


            </p>

        </div>
    </div>

    <div class="card">
        <div class="card_title">11. 交集选择器</div>
        <div class="card_content">
            <p>1.什么是交集选择器?
                作用: 给所有选择器选中的标签中, 相交的那部分标签设置属性

                格式:
                选择器1选择器2{
                属性: 值;
                }

                注意点:
                1.选择器和选择器之间没有任何的连接符号
                2.选择器可以使用标签名称/id名称/class名称
                3.交集选择器仅仅作为了解, 企业开发中用的并不多
                <code>        /*
                    p.para1{
                    color: red;
                    }
                    */
                    .para1#identity{
                    color: blue;
                    }

                </code>

            </p>

        </div>
    </div>
    <div class="card">
        <div class="card_title">12. 并集选择器</div>
        <div class="card_content">
            <p>1.什么是并集选择器?
                作用: 给所有选择器选中的标签设置属性

                格式:
                选择器1,选择器2{
                属性:值;
                }

                注意点:
                1.并集选择器必须使用,来连接
                2.选择器可以使用标签名称/id名称/class名称
                <code> /*
                    .ht{
                    color: red;
                    }
                    .para{
                    color: red;
                    }
                    */
                    .ht,.para{
                    color: red;
                    }

                </code>
            </p>

        </div>
    </div>
    <div class="card">
        <div class="card_title">13. 兄弟选择器</div>
        <div class="card_content">
            <p>1.相邻兄弟选择器 CSS2
                作用: 给指定选择器后面紧跟的那个选择器选中的标签设置属性

                格式:
                选择器1+选择器2{
                属性:值;
                }

                注意点:
                1.相邻兄弟选择器必须通过+连接
                2.相邻兄弟选择器只能选中紧跟其后的那个标签, 不能选中被隔开的标签

                2.通用兄弟选择器 CSS3
                作用: 给指定选择器后面的所有选择器选中的所有标签设置属性

                格式:
                选择器1~选择器2{
                属性:值;
                }

                注意点:
                1.通用兄弟选择器必须用~连接
                2.通用兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签, 无论有没有
                <code>        /*
                    h1+p{
                    color: red;
                    }
                    */
                    h1~p{
                    color: green;
                    }

                </code>
            </p>

        </div>
    </div>
    <div class="card">
        <div class="card_title">14. 序选择器</div>
        <div class="card_content">
            <p>CSS3中新增的选择器最具代表性的就是序选择器
                1.同级别的第几个
                :first-child 选中同级别中的第一个标签
                :last-child 选中同级别中的最后一个标签
                :nth-child(n) 选中同级别中的第n个标签
                :nth-last-child(n) 选中同级别中的倒数第n个标签
                :only-child 选中父元素中唯一的标签
                注意点: 不区分类型

                2.同类型的第几个
                :first-of-type 选中同级别中同类型的第一个标签
                :last-of-type  选中同级别中同类型的最后一个标签
                :nth-of-type(n) 选中同级别中同类型的第n个标签
                :nth-last-of-type(n)  选中同级别中同类型的倒数第n个标签
                :only-of-type 选中父元素中唯一类型的某个标签

                :nth-child(odd) 选中同级别中的所有奇数
                :nth-child(even) 选中同级别中的所有偶数
                :nth-child(xn+y)
                x和y是用户自定义的, 而n是一个计数器, 从0开始递增
                <code>        p:nth-last-child(2){
                    color: red;
                    }
                    */
                    /*
                    p:nth-last-of-type(2){
                    color: red;
                    }
                    */
                    /*
                    p:only-child{
                    color: purple;
                    }
                    */
                    /*
                    p:only-of-type {
                    color: red;
                    }
                    */
                    .para:only-of-type {
                    color: red;
                    }

                </code>
            </p>

        </div>
    </div>
    <div class="card">
        <div class="card_title">15. 属性选择器上</div>
        <div class="card_content">
            <p>1.什么是属性选择器?
                作用: 根据指定的属性名称找到对应的标签, 然后设置属性

                格式:
                [attribute]
                作用:根据指定的属性名称找到对应的标签, 然后设置属性

                [attribute=value]
                作用: 找到有指定属性, 并且属性的取值等于value的标签, 然后设置属性
                最常见的应用场景, 就是用于区分input属性
                input[type=password]{}

                1.属性的取值是以什么开头的
                [attribute|=value] CSS2
                [attribute^=value] CSS3
                两者之间的区别:
                CSS2中的只能找到value开头,并且value是被-和其它内容隔开的
                CSS3中的只要是以value开头的都可以找到, 无论有没有被-隔开

                2.属性的取值是以什么结尾的
                [attribute$=value] CSS3

                3.属性的取值是否包含某个特定的值得
                [attribute~=value] CSS2
                [attribute*=value] CSS3
                两者之间的区别:
                CSS2中的只能找到独立的单词, 也就是包含value,并且value是被空格隔开的
                CSS3中的只要包含value就可以找到

            </p>
            <code>        /*
                p[id]{
                color: red;
                }
                */
                p[class=cc]{
                color: blue;
                }

                /*
                img[alt^=abc]{
                color: red;
                }
                */
                /*
                img[alt|=abc]{
                color: red;
                }
                img[alt$=abc]{
                color: blue;
                }
                */

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">16. 通配符选择器</div>
        <div class="card_content">
            <p>1.什么是通配符选择器?
                作用: 给当前界面上所有的标签设置属性

                格式:
                *{
                属性:值;
                }

                注意点:
                由于通配符选择器是设置界面上所有的标签的属性, 所以在设置之前会遍历所有的标签, 如果当前界面上的标签比较多, 那么性能就会比较差, 所以在企业开发中一般不会使用通配符选择器

            </p>
            <code>        /*
                .cc{
                color: red;
                }
                */
                *{
                color: red;
                }

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">17. CSS三大特性之继承性</div>
        <div class="card_content">
            <p>1.什么是继承性?
                作用: 给父元素设置一些属性, 子元素也可以使用, 这个我们就称之为继承性

                注意点:
                1.并不是所有的属性都可以继承, 只有以color/font-/text-/line-开头的属性才可以继承
                2.在CSS的继承中不仅仅是儿子可以继承, 只要是后代都可以继承
                3.继承性中的特殊性
                3.1a标签的文字颜色和下划线是不能继承的
                3.2h标签的文字大小是不能继承的

                应用场景:
                一般用于设置网页上的一些共性信息, 例如网页的文字颜色, 字体,文字大小等内容
                body{}

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">18. CSS三大特性之层叠性</div>
        <div class="card_content">
            <p>1.什么是层叠性?
                作用: 层叠性就是CSS处理冲突的一种能力

                注意点:
                层叠性只有在多个选择器选中"同一个标签", 然后又设置了"相同的属性", 才会发生层叠性

                CSS全称 Cascading StyleSheet

            </p>
            <code>        p{
                color: red;
                }
                .para{
                color: blue;
                }

            </code>
        </div>
    </div>

    <div class="card">
        <div class="card_title">19. CSS三大特性之优先级</div>
        <div class="card_content">
            <p>1.什么是优先级?
                作用:当多个选择器选中同一个标签, 并且给同一个标签设置相同的属性时, 如何层叠就由优先级来确定

                2.优先级判断的三种方式
                2.1间接选中就是指继承
                如果是间接选中, 那么就是谁离目标标签比较近就听谁的
                2.2相同选择器(直接选中)
                如果都是直接选中, 并且都是同类型的选择器, 那么就是谁写在后面就听谁的
                2.3不同选择器(直接选中)
                如果都是直接选中, 并且不是相同类型的选择器, 那么就会按照选择器的优先级来层叠
                id>类>标签>通配符>继承>浏览器默认

                3.什么是!important
                作用: 用于提升某个直接选中标签的选择器中的某个属性的优先级的, 可以将被指定的属性的优先级提升为最高

                注意点:
                3.1 !important只能用于直接选中, 不能用于间接选中
                3.2 通配符选择器选中的标签也是直接选中的
                3.3 !important只能提升被指定的属性的优先级, 其它的属性的优先级不会被提升
                3.4 !important必须写在属性值得分号前面
                3.5 !important前面的感叹号不能省略

                4.什么是优先级的权重?
                作用: 当多个选择器混合在一起使用时, 我们可以通过计算权重来判断谁的优先级最高

                5.权重的计算规则
                5.1首先先计算选择器中有多少个id, id多的选择器优先级最高
                5.2如果id的个数一样, 那么再看类名的个数, 类名个数多的优先级最高
                5.3如果类名的个数一样, 那么再看标签名称的个数, 标签名称个数多的优先级最高
                5.4如果id个数一样, 类名个数也一样, 标签名称个数也一样, 那么就不会继续往下计算了, 那么此时谁写在后面听谁的
                也就是说优先级如果一样, 那么谁写在后面听谁的

            </p>
            <code>        *{
                color: blue !important;
                font-size:10px;
                }

                #identity1 ul li p{
                color: red;
                }
                #identity1 ul p{
                color: green;
                }

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">20. div和span标签</div>
        <div class="card_content">
            <p>1.什么是div?
                作用: 一般用于配合css完成网页的基本布局

                2.什么是span?
                作用: 一般用于配合css修改网页中的一些局部信息

                3.div和span有什么区别?
                1.div会单独的占领一行,而span不会单独占领一行
                2.div是一个容器级的标签, 而span是一个文本级的标签

                4.容器级的标签和文本级的标签的区别?
                容器级的标签中可以嵌套其它所有的标签
                文本级的标签中只能嵌套文字/图片/超链接

                容器级的标签
                div h ul ol dl li dt dd ...

                文本级的标签
                span p buis strong em ins del ...

                注意点:
                哪些标签是文本级的哪些标签是容器级的, 我们不用刻意去记忆, 在企业开发中一般情况下要嵌套都是嵌套在div中, 或者按照组标签来嵌套

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">21. CSS元素的显示模式</div>
        <div class="card_content">
            <p>在HTML中HTML将所有的标签分为两类, 分别是容器级和文本级
                在CSS中CSS也将所有的标签分为两类, 分别是块级元素(block)和行内元素(inline)

                1.什么是块级元素, 什么是行内元素?
                块级元素会独占一行
                行内元素不会独占一行

                容器级的标签
                div h ul ol dl li dt dd ...
                文本级的标签
                span p buis stong em ins del ...

                块级元素
                p div h ul ol dl li dt dd
                行内元素
                span buis strong em ins del

                2.块级元素和行内元素的区别?
                2.1块级元素
                独占一行
                如果没有设置宽度, 那么默认和父元素一样宽
                如果设置了宽高, 那么就按照设置的来显示

                2.2行内元素
                不会独占一行
                如果没有设置宽度, 那么默认和内容一样宽
                行内元素是不可以设置宽度和高度的

                2.3行内块级元素(inline-block)
                为了能够让元素既能够不独占一行, 又可以设置宽度和高度, 那么就出现了行内块级元素

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">22. CSS元素显示模式转换</div>
        <div class="card_content">
            <p>1.如何转换CSS元素的显示模式?
                设置元素的display属性

                2.display取值
                block 块级
                inline 行内
                inline-block 行内块级

                3.快捷键
                di display: inline;
                db display: block;
                dib display: inline-block;

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">23. 背景颜色</div>
        <div class="card_content">
            <p>1.如何设置标签的背景颜色?
                在CSS中有一个background-color:属性, 就是专门用来设置标签的背景颜色的

                取值:
                具体单词
                rgb
                rgba
                十六进制

                快捷键:
                bc background-color: #fff;

            </p>
            <code>        .box1{
                background-color: red;
                }

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">24. 背景图片</div>
        <div class="card_content">
            <div>1.如何设置背景图片?
                在CSS中有一个叫做background-image: url();的属性, 就是专门用于设置背景图片的

                快捷键:
                bi background-image: url();

                注意点:
                1.图片的地址必须放在url()中, 图片的地址可以是本地的地址, 也可以是网络的地址
                2.如果图片的大小没有标签的大小大, 那么会自动在水平和垂直方向平铺来填充
                3.如果网页上出现了图片, 那么浏览器会再次发送请求获取图片
            <hr>2.如何控制背景图片的平铺方式?
                在CSS中有一个background-repeat属性, 就是专门用于控制背景图片的平铺方式的

                取值:
                repeat 默认, 在水平和垂直都需要平铺
                no-repeat 在水平和垂直都不需要平铺
                repeat-x 只在水平方向平铺
                repeat-y 只在垂直方向平铺

                快捷键
                bgr background-repeat:

                应用场景:
                可以通过背景图片的平铺来降低图片的大小, 提升网页的访问速度
            <hr>3.如何控制背景图片的位置?
                在CSS中有一个叫做background-position:属性, 就是专门用于控制背景图片的位置

                3.1 格式:
                background-position: 水平方向 垂直方向;

                3.2 取值
                1) 具体的方位名词
                水平方向: left center right
                垂直方向: top center bottom

                2) 具体的像素
                例如: background-position: 100px 200px;
                记住一定要写单位, 也就是一定要写px
                记住具体的像素是可以接收负数的

                快捷键:
                bp background-position: 0 0;

                注意点:
                同一个标签可以同时设置背景颜色和背景图片, 如果颜色和图片同时存在, 那么图片会覆盖颜色
            <hr>1.背景属性缩写的格式
            background: 背景颜色 背景图片 平铺方式 关联方式 定位方式;

            快捷键:
            bg+ background: #fff url() 0 0 no-repeat;

            2.注意点：
            background属性中， 任何一个属性都可以被省略

            3.什么是背景关联方式？
            默认情况下背景图片会随着滚动条的滚动而滚动， 如果不想让背景图片随着滚动条的滚动而滚动， 那么我们就可以修改背景图片和滚动条的关联方式

            4.如何修改背景关联方式？
            在CSS中有一个叫做background-attachment的属性， 这个属性就是专门用于修改关联方式的

            格式
            background-attachment：scroll;

            取值：
            scroll 默认值， 会随着滚动条的滚动而滚动
            fixed 不会随着滚动条的滚动而滚动

            快捷键:
            ba background-attachment:;
                <hr>1.背景图片和插入图片区别?
                1.1
                背景图片仅仅是一个装饰, 不会占用位置
                插入图片会占用位置

                1.2
                背景图片有定位属性, 所以可以很方便的控制图片的位置
                插入图片没有定位属性, 所有控制图片的位置不太方便

                1.3
                插入图片的语义比背景图片的语义要强, 所以在企业开发中如果你的图片想被搜索引擎收录, 那么推荐使用插入图片
            </div>
            <code>.box1{
                background-image: url(images/girl.jpg);
                /*background-image: url(http://img4.imgtn.bdimg.com/it/u=2278032206,4196312526&fm=21&gp=0.jpg);*/
                }

                .box1{
                background-image: url(images/girl.jpg);
                background-repeat: repeat-y;
                }

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">25. CSS精灵图</div>
        <div class="card_content">
            <p>1.什么是CSS精灵图
                CSS精灵图是一种图像合成技术

                2.CSS精灵图作用
                可以减少请求的次数, 以及可以降低服务器处理压力

                3.如何使用CSS精灵图
                CSS的精灵图需要配合背景图片和背景定位来使用

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">26. 边框属性</div>
        <div class="card_content">
            <div>1.什么边框?
                边框就是环绕在标签宽度和高度周围的线条

                2.边框属性的格式
                2.1连写(同时设置四条边的边框)
                border: 边框的宽度 边框的样式 边框的颜色;

                快捷键:
                bd+ border: 1px solid #000;

                注意点:
                1.连写格式中颜色属性可以省略, 省略之后默认就是黑色
                2.连写格式中样式不能省略, 省略之后就看不到边框了
                3.连写格式中宽度可以省略, 省略之后还是可以看到边框

                2.2连写(分别设置四条边的边框)
                border-top: 边框的宽度 边框的样式 边框的颜色;
                border-right: 边框的宽度 边框的样式 边框的颜色;
                border-bottom: 边框的宽度 边框的样式 边框的颜色;
                border-left: 边框的宽度 边框的样式 边框的颜色;

                快捷键:
                bt+ border-top: 1px solid #000;
                br+
                bb+
                bl+
                <code>        .box{
                    width: 100px;
                    height: 100px;
                    background-color: red;
                    /*border: 5px solid blue;*/
                    /*border: 5px solid;*/
                    /*border: 5px blue;*/
                    /*border: solid blue;*/

                    border-top:5px solid blue;
                    border-right:10px dashed green;
                    border-bottom:15px dotted purple;
                    border-left:20px double pink;
                    }</code>
                <hr>2.3连写(分别设置四条边的边框)
                border-width: 上 右 下 左;
                border-style: 上 右 下 左;
                border-color: 上 右 下 左;

                注意点:
                1.这三个属性的取值是按照顺时针来赋值, 也就是按照上右下左来赋值, 而不是按照日常生活中的上下左右
                2.这三个属性的取值省略时的规律
                2.1上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
                2.2上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
                2.3上 右 下 左 > 上 > 右下左边取值和上边一样


                3.非连写(方向+要素)
                border-left-width: 20px;
                border-left-style: double;
                border-left-color: pink;

            </div>
            <code>    border-style: solid dashed dotted double;
                border-color: blue green purple pink;
                border-color: blue green purple;
                border-color: blue green;
                border-color: blue;

                border-top-width: 5px;
                border-top-style: solid;
                border-top-color: blue;

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">27. 内边距属性</div>
        <div class="card_content">
            <p>1.什么是内边距?
                边框和内容之间的距离就是内边距

                2.格式
                2.1非连写
                padding-top: ;
                padding-right: ;
                padding-bottom: ;
                padding-left: ;

                2.2连写
                padding: 上 右 下 左;

                2.这三个属性的取值省略时的规律
                2.1上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
                2.2上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
                2.3上 右 下 左 > 上 > 右下左边取值和上边一样

                注意点:
                1.给标签设置内边距之后, 标签占有的宽度和高度会发生变化
                2.给标签设置内边距之后, 内边距也会有背景颜色
                <code> .box1{
                    padding-top: 20px;
                    }</code>

            </p>

        </div>
    </div>
    <div class="card">
        <div class="card_title">28. 外边距属性</div>
        <div class="card_content">
            <div>1.什么是外边距?
                标签和标签之间的距离就是外边距

                2.格式
                2.1非连写
                margin-top: ;
                margin-right: ;
                margin-bottom: ;
                margin-left: ;

                2.2连写
                margin: 上 右 下 左;

                2.这三个属性的取值省略时的规律
                2.1上 右 下 左 > 上 右 下 > 左边的取值和右边的一样
                2.2上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样
                2.3上 右 下 左 > 上 > 右下左边取值和上边一样

                注意点:
                外边距的那一部分是没有背景颜色的
<code>margin-bottom:80px;
    margin-left:160px;

    margin:20px 40px 80px 160px;
    margin:20px 40px 80px;</code>
                <hr>
在默认布局的垂直方向上, 默认情况下外边距是不会叠加的, 会出现合并现象, 谁的外边距比较大就听谁的
            </div>

        </div>
    </div>
    <div class="card">
        <div class="card_title">29. CSS盒子模型</div>
        <div class="card_content">
            <div>1.什么是CSS盒子模型?
                CSS盒子模型仅仅是一个形象的比喻, HTML中所有的标签都是盒子

                结论
                1.在HTML中所有的标签都可以设置
                宽度/高度  == 指定可以存放内容的区域
                内边距  == 填充物
                边框  == 手机盒子自己
                外边距  == 盒子和盒子之间的间隙
            <hr>1.内容的宽度和高度
            就是通过width/height属性设置的宽度和高度

            2.元素的宽度和高度
            宽度 = 左边框 + 左内边距 + width + 右内边距 + 右边框
            高度 同理可证

            3.元素空间的宽度和高度
            宽度 = 左外边距 + 左边框 + 左内边距 + width + 右内边距 + 右边框 + 右外边距
            高度 同理可证
            <hr>1.CSS3中新增了一个box-sizing属性, 这个属性可以保证我们给盒子新增padding和border之后, 盒子元素的宽度和高度不变
            2.box-sizing属性是如何保证增加padding和border之后, 盒子元素的宽度和高度不变
            和我们前面学习的原理一样, 增加padding和border之后要想保证盒子元素的宽高不变, 那么就必须减去一部分内容的宽度和高度
            3.box-sizing取值
            3.1content-box
            元素的宽高 = 边框 + 内边距 + 内容宽高
            3.2border-box
            元素的宽高 = width/height的宽高
            <hr>1.text-align:center;和margin:0 auto;区别
            text-align: center;作用
            设置盒子中存储的文字/图片水平居中

            margin:0 auto;作用
            让盒子自己水平居中
            <hr>1.为什么要清空默认边距(外边距和内边距)
            在企业开发中为了更好的控制盒子的宽高和计算盒子的宽高等等, 所以在企业开发中, 编写代码之前第一件事情就是清空默认的边距

            2.如何清空默认的边距
            格式
            *{
            margin: 0;
            padding: 0;
            }

            3.注意点
            通配符选择器会找到(遍历)当前界面中所有的标签, 所以性能不好
            <code>html{color:#000;background:#FFF}
                body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,
                pre,code,form,fieldset,legend,input,textarea,
                p,blockquote,th,td{margin:0;padding:0}
                table{border-collapse:collapse;border-spacing:0}
                fieldset,img{border:0}
                address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal}
                ol,ul{list-style:none}
                caption,th{text-align:left}
                h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal}
                q:before,q:after{content:''}abbr,acronym{border:0;font-variant:normal}
                sup{vertical-align:text-top}
                sub{vertical-align:text-bottom}
                input,textarea,select{font-family:inherit;
                font-size:inherit;font-weight:inherit;*font-size:100%}
                legend{color:#000}#yui3-css-stamp.cssreset{display:none}
                a{text-decoration: none; color: #999}

            </code>
        </div>
        </div>

    </div>
    <div class="card">
        <div class="card_title">30. 行高和字号</div>
        <div class="card_content">
            <div>1.什么是行高?
                在CSS中所有的行都有自己的行高

                注意点:
                行高和盒子高不是同一个概念
                行高指的是每行内容的高度
                盒子高指的是元素的高度

                规律:
                1.文字在行高中默认是垂直居中的

                2.在企业开发中我们经常将盒子的高度和行高设置为一样, 那么这样就可以保证一行文字在盒子的高度中是垂直居中的
                简而言之就是: 要想一行文字在盒子中垂直居中, 那么只需要设置这行文字的"行高等于盒子的高"即可

                3.在企业开发中如果一个盒子中有多行文字, 那么我们就不能使用设置行高等于盒子高来实现让文字垂直居中, 只能通过设置padding来让文字居中
            <hr>1.在企业开发中, 如果一个盒子中存储的是文字, 那么一般情况下我们会以盒子左边的内边距为基准, 不会以右边的内边距为基准, 因为这个右边的内边距有误差

            2.右边内边距的误差从何而来? 因为右边如果放不下一个文字, 那么文字就会换行显示, 所以文字和内边距之间的距离就有了误差

            3.顶部的内边距并不是边框到文字顶部的距离, 而是边框到行高顶部的距离
            </div>

        </div>
    </div>
    <div class="card">
        <div class="card_title">31. 网页的布局方式</div>
        <div class="card_content">
            <p>1.什么是网页的布局方式?
                网页的布局方式其实就是指浏览器是如何对网页中的元素进行排版的

                1.标准流(文档流/普通流)排版方式
                1.1其实浏览器默认的排版方式就是标准流的排版方式
                1.2在CSS中将元素分为三类, 分别是块级元素/行内元素/行内块级元素
                1.3 在标准流中有两种排版方式, 一种是垂直排版, 一种是水平排版
                垂直排版, 如果元素是块级元素, 那么就会垂直排版
                水平排版, 如果元素是行内元素/行内块级元素, 那么就会水平排版

                2.浮动流排版方式
                2.1浮动流是一种"半脱离标准流"的排版方式
                2.2浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐

                注意点:
                1.浮动流中没有居中对齐, 也就是没有center这个取值
                2.在浮动流中是不可以使用margin: 0 auto;

                特点:
                1.在浮动流中是不区分块级元素/行内元素/行内块级元素的
                无论是级元素/行内元素/行内块级元素都可以水平排版
                2.在浮动流中无论是块级元素/行内元素/行内块级元素都可以设置宽高
                3.综上所述, 浮动流中的元素和标准流中的行内块级元素很像

                3.定位流排版方式

            </p>
            <code>

            </code>
        </div>
    </div>
    <div class="card">
        <div class="card_title">32. float</div>
        <div class="card_content">
            <div>1.什么是浮动元素的脱标?
                脱标: 脱离标准流
                当某一个元素浮动之后, 那么这个元素看上去就像被从标准流中删除了一样, 这个就是浮动元素的脱标

                2.浮动元素脱标之后会有什么影响?
                如果前面一个元素浮动了, 而后面一个元素没有浮动 , 那么这个时候前面一个元就会盖住后面一个元素

            <hr>1.浮动元素排序规则
            1.1相同方向上的浮动元素, 先浮动的元素会显示在前面, 后浮动的元素会显示在后面
            1.2不同方向上的浮动元素, 左浮动会找左浮动, 右浮动会找右浮动
            1.3浮动元素浮动之后的位置, 由浮动元素浮动之前在标准流中的位置来确定
            <hr>1.什么是浮动元素贴靠现象?
            1.如果父元素的宽度能够显示所有浮动元素, 那么浮动的元素会并排显示
            2.如果父元素的宽度不能显示所有浮动元素, 那么会从最后一个元开始往前贴靠
            3.如果贴靠了前面所有浮动元素之后都不能显示, 最终会贴靠到父元素的左边或者右
            <hr>1.什么是浮动元素字围现象?
            浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位
            <hr>1.在标准流中内容的高度可以撑起父元素的高度
            2.在浮动流中浮动的元素是不可以撑起父元素的高度的
        </div>            </div>

    </div>
    <div class="card">
        <div class="card_title">33. 清除浮动</div>
        <div class="card_content">
            <div>1.清除浮动的第一种方式
                给前面一个父元素设置高度

                注意点:
                在企业开发中, 我们能不写高度就不写高度, 所以这种方式用得很少

            <hr>1.清除浮动的第二种方式
            给后面的盒子添加clear属性

            clear属性取值:
            none: 默认取值, 按照浮动元素的排序规则来排序(左浮动找左浮动, 右浮动找右浮动)
            left: 不要找前面的左浮动元素
            right: 不要找前面的右浮动元素
            both: 不要找前面的左浮动元素和右浮动元素

            注意点:
            当我们给某个元素添加clear属性之后, 那么这个属性的margin属性就会失效
            <hr>1.清除浮动的第三种方式
            隔墙法

            2.外墙法
            2.1在两个盒子中间添加一个额外的块级元素
            2.2给这个额外添加的块级元素设置clear: both;属性

            注意点:
            外墙法它可以让第二个盒子使用margin-top属性
            外墙法不可以让第一个盒子使用margin-bottom属性

            3.内墙法
            3.1在第一个盒子中所有子元素最后添加一个额外的块级元素
            3.2给这个额外添加的块级元素设置clear: both;属性

            注意点:
            内墙法它可以让第二个盒子使用margin-top属性
            内墙法它可以让第一个盒子使用margin-bottom属性

            4.外墙法和内墙法区别?
            外墙法不能撑起第一个盒子的高度, 而内墙法可以撑起第一个盒子的高度

            5.在企业开发中不常用隔墙法来清除浮动
        </div>
        </div>

    </div>
    <div class="card">
        <div class="card_title">34. 伪元素选择器</div>
        <div class="card_content">
            <p>1.什么是伪元素选择器?
                伪元素选择器作用就是给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素

                2.格式:
                标签名称::before{
                属性名称:值;
                }
                给指定标签的内容前面添加一个子元素

                标签名称::after{
                属性名称:值;
                }
                给指定标签的内容后面添加一个子元素

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">35. overflow: hidden</div>
        <div class="card_content">
            <p>1.overflow: hidden;作用
                1.1可以将超出标签范围的内容裁剪掉
                1.2清除浮动
                1.3可以通过overflow: hidden;让里面的盒子设置margin-top之后, 外面的盒子不被顶下来
                -->

            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">36. 定位流</div>
        <div class="card_content">
            <div>1.定位流分类
                1.1相对定位
                1.2绝对定位
                1.3固定定位
                1.4静态定位
                <h3>相对定位</h3>2.什么是相对定位?
                相对定位就是相对于自己以前在标准流中的位置来移动 (通过top, right,  bottom, left属性移动)

                3.相对定位注意点
                3.1相对定位是不脱离标准流的, 会继续在标准流中占用一份空间
                3.2在相对定位中同一个方向上的定位属性只能使用一个
                3.3由于相对定位是不脱离标准流的, 所以在相对定位中是区分块级元素/行内元素/行内块级元素
                3.4由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位的元素设置margin/padding等属性的时会影响到标准流的布局
                （margin/padding只加到定位前标准流中的位置上，而不是加到定位后的位置上）

                4.相对定位应用场景
                4.1用于对元素进行微调
                4.2配合后面学习的绝对定位来使用
                <hr><h3>绝对定位</h3>1.什么是绝对定位?
                绝对定位就是相对于body或有定位流的父元素来定位

                2.绝对定位注意点
                2.1绝对定位的元素是脱离标准流的
                2.2绝对定位的元素是不区分块级元素/行内元素/行内块级元素
                <hr>绝对定位参考点规律
                1.默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以body作为参考点

                2.如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点
                2.1只要是这个绝对定位元素的祖先元素都可以
                2.2指的定位流是指绝对定位/相对定位/固定定位
                2.3定位流中只有静态定位不行

                3.如果一个绝对定位的元素有祖先元素, 并且祖先元素也是定位流, 而且祖先元素中有多个元素都是定位流, 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点
                <hr>注意点
                1.如果一个绝对定位的元素是以body作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点

                2.一个绝对定位的元素会忽略祖先元素的padding
                <hr>相对定位弊端:
                相对定位不会脱离标准流, 会继续在标准流中占用一份空间, 所以不利于布局界面
                position: relative;
                left: -42px;
                top: -18px;

                绝对定位弊端:
                默认情况下绝对定位的元素会以body作为参考点, 所以会随着浏览器的宽度高度的变化而变化
                position: absolute;
                left: 526px;
                top: 90px;

                子绝父相
                子元素用绝对定位, 父元素用相对定位
                <hr>1.如何让绝对定位的元素水平居中
                只需要设置绝对定位元素的left:50%;
                然后再设置绝对定位元素的 margin-left: -元素宽度的一半px;
                <hr><h3>固定定位</h3>1.什么是固定定位?
                固定定位和前面学习的背景关联方式很像, 背景定位可以让背景图片不随着滚动条的滚动而滚动, 而固定定位可以让某个盒子不随着滚动条的滚动而滚动

                注意点:
                1.固定定位的元素是脱离标准流的, 不会占用标准流中的空间
                2.固定定位和绝对定位一样不区分行内/块级/行内块级
                3.IE6不支持固定定位
                <hr><h3>z-index属性</h3>1.什么是z-index属性?
                默认情况下所有的元素都有一个默认的z-index属性, 取值是0.
                z-index属性的作用是专门用于控制定位流元素的覆盖关系的

                1.默认情况下定位流的元素会盖住标准流的元素
                2.默认情况下定位流的元素后面编写的会盖住前面编写的
                3.如果定位流的元素设置了z-index属性, 那么谁的z-index属性比较大, 谁就会显示在上面

                注意点:
                1.从父现象
                1.1如果两个元素的父元素都没有设置z-index属性, 那么谁的z-index属性比较大谁就显示在上面
                1.2如果两个元素的父元素设置了z-index属性, 那么子元素的z-index属性就会失效, 也就是说谁的父元素的z-index属性比较大谁就会显示在上面

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">37. a标签的伪类选择器</div>
        <div class="card_content">
            <div>1.通过我们的观察发现a标签存在一定的状态
                1.1默认状态, 从未被访问过
                1.2被访问过的状态
                1.3鼠标长按状态
                1.4鼠标悬停在a标签上状态

                2.什么是a标签的伪类选择器?
                a标签的伪类选择器是专门用来修改a标签不同状态的样式的

                3.格式
                :link 修改从未被访问过状态下的样式
                :visited 修改被访问过的状态下的样式
                :hover 修改鼠标悬停在a标签上状态下的样式
                :active 修改鼠标长按状态下的样式

                4.注意点
                4.1a标签的伪类选择器可以单独出现也可以一起出现
                4.2a标签的伪类选择器如果一起出现, 那么有严格的顺序要求
                编写的顺序必须要个的遵守爱恨原则 love hate
                4.3如果默认状态的样式和被访问过状态的样式一样, 那么可以缩写

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">38. 过渡模块</div>
        <div class="card_content">
            <div><h3>过渡三要素</h3>
                1.1必须要有属性发生变化
                1.2必须告诉系统哪个属性需要执行过渡效果
                1.3必须告诉系统过渡效果持续时长

                2.注意点
                当多个属性需要同时执行过渡效果时用逗号隔开即可
                transition-property: width, background-color;
                transition-duration: 5s, 5s;
                <code>       div{
                    width: 100px;
                    height: 50px;
                    background-color: red;

                    /*告诉系统哪个属性需要执行过渡效果*/
                    transition-property: width, background-color;
                    /*告诉系统过渡效果持续的时长*/
                    transition-duration: 5s, 5s;

                    /*transition-property: background-color;*/
                    /*transition-duration: 5s;*/
                    }
                    /*:hover这个伪类选择器除了可以用在a标签上, 还可以用在其它的任何标签上*/
                    div:hover{
                    width: 300px;
                    background-color: blue;
                    }</code>
                <hr><h3>过渡模块-其它属性</h3><code>div {
                    width: 100px;
                    height: 50px;
                    background-color: red;
                    transition-property: width;
                    transition-duration: 5s;
                    /*告诉系统延迟多少秒之后才开始过渡动画*/
                    /*transition-delay: 2s;*/
                    }
                    ul li:nth-child(1){
                    /*告诉系统过渡动画的运动的速度*/
                    transition-timing-function: linear;
                    }
                    ul li:nth-child(2){
                    transition-timing-function: ease;
                    }
                    ul li:nth-child(3){
                    transition-timing-function: ease-in;
                    }
                    ul li:nth-child(4){
                    transition-timing-function: ease-out;
                    }
                    ul li:nth-child(5){
                    transition-timing-function: ease-in-out;
                    }</code>
                <hr><h3>连写</h3>1.过渡连写格式
                transition: 过渡属性 过渡时长 运动速度 延迟时间;

                2.过渡连写注意点
                2.1和分开写一样, 如果想给多个属性添加过渡效果也是用逗号隔开即可
                2.2连写的时可以省略后面的两个参数, 因为只要编写了前面的两个参数就已经满足了过渡的三要素
                2.3如果多个属性运动的速度/延迟的时间/持续时间都一样, 那么可以简写为
                transition:all 0s;
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">39. 2D转换模块</div>
        <div class="card_content">
            <div><code>   ul li:nth-child(2){
                /*其中deg是单位, 代表多少度*/
                transform: rotate(45deg);
                }
                ul li:nth-child(3){
                /*
                第一个参数:水平方向
                第二个参数:垂直方向
                */
                transform: translate(100px, 0px);
                }
                ul li:nth-child(4){
                /*
                第一个参数:水平方向
                第二个参数:垂直方向
                注意点:
                如果取值是1, 代表不变
                如果取值大于1, 代表需要放大
                如果取值小于1, 代表需要缩小
                如果水平和垂直缩放都一样, 那么可以简写为一个参数
                */
                /*transform: scale(0.5, 0.5);*/
                transform: scale(1.5);
                }
                ul li:nth-child(5){
                /*
                注意点:
                1.如果需要进行多个转换, 那么用空格隔开
                2.2D的转换模块会修改元素的坐标系, 所以旋转之后再平移就不是水平平移的
                */
                transform: rotate(45deg) translate(100px, 0px) scale(1.5, 1.5);
                /*transform: translate(100px, 0px);*/
                }</code>
                <hr><h3>形变中心点</h3>默认情况下所有的元素都是以自己的中心点作为参考来旋转的, 我们可以通过形变中心点属性来修改它的参考点
                <code>    /*transform-origin: 200px 0px;*/
                    /*transform-origin: 50% 50%;*/
                    /*transform-origin: 0% 0%;*/
                    /*transform-origin: center center;*/
                    transform-origin: left top;</code>第一个参数:水平方向
                第二个参数:垂直方向

                注意点
                取值有三种形式
                具体像素
                百分比
                特殊关键字
                <hr><h3>旋转轴向</h3>默认情况下所有元素都是围绕Z轴进行旋转
                总结:
                想围绕哪个轴旋转, 那么只需要在rotate后面加上哪个轴即可
                <code>transform: rotateY(45deg);</code>1.什么是透视
                近大远小
                2.注意点
                一定要注意, 透视属性必须添加到需要呈现近大远小效果的元素的父元素上面
                <code>perspective: 500px;</code>
            </div>
        </div>
    </div>

    <div class="card">
        <div class="card_title">40. 盒子阴影和文字阴影</div>
        <div class="card_content">
            <p>1.如何给盒子添加阴影
                box-shadow: 水平偏移 垂直偏移 模糊度 阴影扩展 阴影颜色 内外阴影;

                2.注意点
                2.1盒子的阴影分为内外阴影, 默认情况下就是外阴影
                2.2快速添加阴影只需要编写三个参数即可
                box-shadow: 水平偏移 垂直偏移 模糊度;
                默认情况下阴影的颜色和盒子内容的颜色一致

                3.如何给文字添加阴影
                text-shadow: 水平偏移 垂直偏移 模糊度 阴影颜色 ;
            </p>
        </div>
    </div>
    <div class="card">
        <div class="card_title">41. 动画模块</div>
        <div class="card_content">
            <div>1.过渡和动画之间的异同
                1.1不同点
                过渡必须人为的触发才会执行动画
                动画不需要人为的触发就可以执行动画

                1.2相同点
                过渡和动画都是用来给元素添加动画的
                过渡和动画都是系统新增的一些属性
                过渡和动画都需要满足三要素才会有动画效果
                <code> div{
                    width: 100px;
                    height: 50px;
                    background-color: red;

                    /*1.告诉系统需要执行哪个动画*/
                    animation-name: lnj;
                    /*3.告诉系统动画持续的时长*/
                    animation-duration: 3s;
                    }
                    /*2.告诉系统我们需要自己创建一个名称叫做lnj的动画*/
                    @keyframes lnj {
                    from{
                    margin-left: 0;
                    }
                    to{
                    margin-left: 500px;
                    }
                    }</code>
                <hr><h3>其他属性</h3><code>div {
                    width: 100px;
                    height: 50px;
                    background-color: red;
                    animation-name: sport;
                    animation-duration: 2s;
                    /*告诉系统多少秒之后开始执行动画*/
                    /*animation-delay: 2s;*/
                    /*告诉系统动画执行的速度*/
                    animation-timing-function: linear;
                    /*告诉系统动画需要执行几次*/
                    animation-iteration-count: 3;
                    /*告诉系统是否需要执行往返动画
                    取值:
                    normal, 默认的取值, 执行完一次之后回到起点继续执行下一次
                    alternate, 往返动画, 执行完一次之后往回执行下一次
                    */
                    animation-direction: alternate;
                    }
                    @keyframes sport {
                    from{
                    margin-left: 0;
                    }
                    to{
                    margin-left: 500px;
                    }
                    }
                    div:hover{
                    /*
                    告诉系统当前动画是否需要暂停
                    取值:
                    running: 执行动画
                    paused: 暂停动画
                    */
                    animation-play-state: paused;
                    }</code><br>通过我们的观察, 动画是有一定的状态的
                1.等待状态
                2.执行状态
                3.结束状态

                animation-fill-mode作用:
                指定动画等待状态和结束状态的样式
                取值:
                none: 不做任何改变
                forwards: 让元素结束状态保持动画最后一帧的样式
                backwards: 让元素等待状态的时候显示动画第一帧的样式
                both: 让元素等待状态显示动画第一帧的样式, 让元素结束状态保持动画最后一帧的样式
                <code>.box2{
                    width: 200px;
                    height: 200px;
                    background-color: blue;
                    margin: 100px auto;
                    animation-name: myRotate;
                    animation-duration: 5s;
                    animation-delay: 2s;
                    /*animation-fill-mode: backwards;*/
                    /*animation-fill-mode: forwards;*/
                    animation-fill-mode: both;}</code>
                <hr>1.动画模块连写格式
                animation:动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画;

                2.动画模块连写格式的简写
                animation:动画名称 动画时长;
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">42. 3d转换</div>
        <div class="card_content">
            <div>1.什么是2D和3D
                2D就是一个平面, 只有宽度和高度, 没有厚度
                3D就是一个立体, 有宽度和高度, 还有厚度
                默认情况下所有的元素都是呈2D展现的
                2.如何让某个元素呈3D展现
                和透视一样, 想看到某个元素的3d效果, 只需要给他的父元素添加一个transform-style属性, 然后设置为preserve-3d即可
                */
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">43. 背景尺寸属性</div>
        <div class="card_content">
            <div>1.什么是背景尺寸属性
                背景尺寸属性是CSS3中新增的一个属性, 专门用于设置背景图片大小
                <code>ul li:nth-child(1){
                    background: url("images/dog.jpg") no-repeat;
                    }
                    ul li:nth-child(2){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    第一个参数:宽度
                    第二个参数:高度
                    */
                    background-size:200px 100px;
                    }
                    ul li:nth-child(3){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    第一个参数:宽度
                    第二个参数:高度
                    */
                    background-size:100% 80%;
                    }
                    ul li:nth-child(4){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    第一个参数:宽度
                    第二个参数:高度
                    */
                    background-size:auto 100px;
                    }
                    ul li:nth-child(5){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    第一个参数:宽度
                    第二个参数:高度
                    */
                    background-size:100px auto;
                    }
                    ul li:nth-child(6){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    cover含义:
                    1.告诉系统图片需要等比拉伸
                    2.告诉系统图片需要拉伸到宽度和高度都填满元素
                    */
                    background-size:cover;
                    }
                    ul li:nth-child(7){
                    background: url("images/dog.jpg") no-repeat;
                    /*
                    c含义:
                    1.告诉系统图片需要等比拉伸
                    2.告诉系统图片需要拉伸到宽度或高度都填满元素
                    */
                    background-size:contain;
                    }</code>
                <hr><h3>背景图片定位区域属性</h3><code>  ul li:nth-child(2){
                    /*
                    告诉系统背景图片从什么区域开始显示,
                    默认情况下就是从padding区域开始显示
                    */
                    background-origin: padding-box;
                    }
                    ul li:nth-child(3){
                    background-origin:border-box;
                    }
                    ul li:nth-child(4){
                    background-origin:content-box;
                    }
                </code>
                <hr><h3>背景绘制区域属性</h3><code>ul li:nth-child(2){
                    /*
                    背景绘制区域属性是专门用于指定从哪个区域开始绘制背景的, 默认情况下会从border区域开始绘制背景
                    */
                    background-clip: padding-box;
                    }
                    ul li:nth-child(3){
                    background-clip: border-box;
                    }
                    ul li:nth-child(4){
                    background-clip: content-box;
                    }</code>
                <hr><h3>多重背景图片</h3><code>     div{
                    width: 500px;
                    height: 500px;
                    border: 1px solid #000;
                    margin: 0 auto;
                    /*
                    多张背景图片之间用逗号隔开即可
                    注意点:
                    先添加的背景图片会盖住后添加的背景图片
                    建议在编写多重背景时拆开编写
                    */
                    /*background: url("images/animal1.png") no-repeat left top,url("images/animal2.png") no-repeat right top,url("images/animal3.png") no-repeat left bottom,url("images/animal4.png") no-repeat right bottom,url("images/animal5.png") no-repeat center center;*/
                    background-image: url("images/animal1.png"),url("images/animal2.png"),url("images/animal3.png");
                    background-repeat: no-repeat, no-repeat, no-repeat;
                    background-position: left top, right top, left bot</code>

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">44. 边框圆角</div>
        <div class="card_content">
            <div>
                1.什么是边框圆角?
                将直角的边框变为圆角的边框

                2.边框圆角的格式?
                border-radius: 左上 右上 右下 左下;

                3.将正方形变为圆形的技巧
                border-radius: 50%;

                4.系统如何绘制圆角?
                首先根据指定的值找到圆心
                按照指定的值作为半径绘制圆弧
            <hr><h3>边框圆角注意点</h3>                左上  右上  右下  左下
            border-radius: 100px 100px 100px 100px;
            border-radius: 100px 50px 100px 100px;<br>
            当省略了某一个角的值之后, 系统会自动参考对角的值
            border-radius: 100px 50px 100px;
                <br>当只设置了一个值的时候, 其它三个角都会参考这个值
                当边框圆角的值 > 边框宽度的时候, 外边框和内边框都会变成圆角
                当边框圆角的值 <= 边框宽度的时候, 外边框是圆角, 内边框是直角
                <hr><h3>半圆</h3>
<code>.one{
    width: 200px;
    height: 100px;
    border: 1px solid #000;
    box-sizing: border-box;
    margin: 100px auto;
    /*可以通过border-xxx-xx-radius的方式单独设置某一个角的值
    border-xxx-xx-radius接收两个参数, 第一个表示水平方向, 第二个表示垂直方向
    border-xxx-xx-radius如果只传递了一个参数, 那么出自方向和水平方向的值一样*/
    /*                        水平  垂直*/
    /*border-top-left-radius: 100px 100px;*/
    border-top-left-radius: 100px;
    border-top-right-radius: 100px;
    }</code>
                <hr><h3>椭圆</h3>
                <code>.two{
                    width: 400px;
                    height: 200px;
                    border: 1px solid #000;
                    box-sizing: border-box;
                    margin: 300px auto;
                    /*绘制椭圆设置水平方向为宽度的一半, 设置垂直方向为高度的一半*/
                    border-top-left-radius: 200px 100px;
                    border-top-right-radius: 200px 100px;
                    border-bottom-left-radius: 200px 100px;
                    border-bottom-right-rad
                </code>

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">45. 边框图片</div>
        <div class="card_content">
            <div><code>/*告诉浏览器让哪一张图片成为边框*/
                /*注意点:
                如果只通过source指定了哪一张图片作为边框的图片, 默认情况下会将图片放到边框的四个顶点
                如果设置了边框图片, 那么就不会显示边框颜色, 边框图片的优先级高于边框颜色*/
                border-image-source: url("images/border.jpg");
                /*告诉浏览器如何对指定的边框图片进行切割
                注意点: 不带单位
                */
                border-image-slice: 70 70 70 70;
                /*告诉浏览器边框图片显示的宽度, 并不是指定边框的宽度
                注意点: 如果通过border-image-width指定了边框图片的宽度, 那么默认的边框宽度就会失效*/
                /*border-image-width: 10px;*/

                /*告诉浏览器除了边框图片四个角以外的图片如何填充, 默认是拉伸*/
                /*border-image-repeat: stretch;*/
                /*border-image-repeat: repeat;*/
                border-image-repeat: round;
                /*告诉浏览器边框图片需要向外移动多少
                上   右   下   左*/
                border-image-outset: 10px 30px 50px 70px;
                <br>缩写:
                /*border-image: 资源地址 切割方式 填充模式;*/
                border-image: url("images/border.jpg") 70 fill repeat;
            </code>
            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">46. vertical align</div>
        <div class="card_content">
            <div><code>img{
                /*默认情况下图片和一行文字的基线对齐
                基线就是一行文字中最短那个文字的底部*/
                /*vertical-align: baseline;*/
                /*vertical-align: top;*/
                /*vertical-align: bottom;*/
                /*vertical-align: text-top;*/
                /*vertical-align: text-bottom;*/
                vertical-align: middle;
                }</code>
                <br>
                1.什么是vertical-align?
                设置元素的垂直对齐方式。

                2.vertical-align注意点:
                text-align是设置给需要对齐元素的父元素
                vertical-align是设置给需要对齐的那个元素本身

                vertical-align只对行内元素有效

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">47. 线性渐变</div>
        <div class="card_content">
            <div><code>div{
                width: 300px;
                height: 200px;
                border: 1px solid #000;
                box-sizing: border-box;
                margin: 200px auto;
                /*默认情况下会从上至下的渐变*/
                /*background: linear-gradient(red, green);*/
                /*background: linear-gradient(to top ,red, green);*/
                /*background: linear-gradient(to right ,red, green);*/
                /*background: linear-gradient(to left ,red, green);*/
                /*background: linear-gradient(to top right ,red, green);*/
                background: linear-gradient(45deg ,red, green);
                }</code>

                <br>
                <code>            /*
                    注意点:
                    至少需要传递2个颜色, 至多没有上限
                    */
                    /*background: linear-gradient(to right, red, green, blue, yellow);*/
                    /*
                    注意点:
                    默认情况下自动回自动计算纯色和渐变色的范围, 但是我们也可以手动指定
                    手动指定的格式: 颜色 范围
                    只有第一个颜色后面的范围是指定纯色的范围, 后面的都是指定渐变的范围
                    */
                    background: linear-gradient(to right, red 100px, green 200px, blue 300px);</code>

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">48. 径向渐变</div>
        <div class="card_content">
            <div><code> div{
                width: 400px;
                height: 400px;
                border: 1px solid #000;
                margin: 200px auto;
                /*
                线性渐变: 默认从上至下
                径向渐变: 默认从中心点向四周扩散
                */
                /*background: radial-gradient(red, green);*/

                /*
                线性渐变: 可以通过to 关键字的方式修改渐变的方向
                径向渐变: 可以通过at 关键字的方式修改开始渐变的位置
                */
                /*background: radial-gradient(at top left ,red, green);*/

                /*
                线性渐变: 可以通过to deg的方式修改渐变的方向
                径向渐变: 可以通过at 位置 位置的方式修改开始渐变的位置
                */
                /*background: radial-gradient(at 200px 100px ,red, green);*/

                /*
                线性渐变可以指定纯色和渐变的范围
                径向渐变也可以指定扩散的范围
                */
                /*background: radial-gradient(100px, red, green);*/

                /*
                注意点:
                如果需要同时指定扩散的位置和扩散的范围, 那么范围必须写到at前面
                */
                background: radial-gradient(100px at 200px 100px ,red, green);
                }</code>

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">49. 伸缩布局</div>
        <div class="card_content">
            <div>
            1. 伸缩容器: display: flex的元素
            2. 伸缩项: 伸缩容器中的元素

                <br><h3>主轴的方向</h3>
                <code>  在伸缩布局中, 默认情况下水平方向是主轴, 默认情况下主轴的起点在伸缩容器的最左边, 默认情况下所有的伸缩项都是从主轴的起点开始排版的
                    但是我们也可以通过属性来修改主轴的起点的位置

                    flex-direction: 用于修改主轴起点的位置
                    row: 起点在伸缩容器的最左边, 终点在伸缩容器的最右边.   从左至右的排版, 默认的取值
                    row-reverse: 起点在伸缩容器的最右边, 终点在伸缩容器的最左边, 从右至左的排版
                    column: 起点在伸缩容器的最顶部, 终点在伸缩容器的最底部, 从上至下的排版
                    注意点: 在伸缩布局中主轴和侧轴永远都是十字交叉的, 只要主轴的方向发生了变化, 侧轴也会发生变化
                    column-reverse: 起点在伸缩容器的最底部, 终点在伸缩容器的最顶部, 从下至上的排版
                    */
                    /*flex-direction: row;*/
                    /*flex-direction: row-reverse;*/
                    /*flex-direction: column;*/
                    flex-direction: column-reverse;</code>
                <br><h3>主轴的对齐方式</h3>
                <code> display: flex;
                    /*
                    flex-direction: row; 主轴起点的默认值
                    justify-content: flex-start; 主轴上伸缩项对齐的默认值
                    注意点: 在设置对齐方式的时候一定要理解两步操作
                    1.按照主轴起点对伸缩项进行排版
                    2.按照指定的对齐方式对齐排版好的伸缩项
                    */
                    flex-direction: row;
                    /*justify-content: flex-start;*/
                    /*justify-content: flex-end;*/
                    /*justify-content: center;*/
                    /*justify-content: space-between;*/
                    justify-content: space-around;</code>
                <br><h3>侧轴的对齐方式</h3>
                <code> display: flex;
                    /*告诉浏览器主轴的起点在伸缩容器的最左边, 告诉浏览器伸缩项从左至右的排版*/
                    flex-direction: row;
                    /*告诉浏览器排版好的伸缩项需要和主轴的起点对齐*/
                    justify-content: flex-start;
                    /*告诉浏览器排版好的伸缩项需要和侧轴的起点对齐*/
                    /*align-items: flex-start;*/
                    /*align-items: flex-end;*/
                    /*align-items: center;*/
                    /*
                    注意点:
                    侧轴对比主轴来说没有两端对齐(space-between)和环绕对齐(space-around)
                    */
                    /*baseline: 让所有伸缩项中的基线在一条直线上对齐*/
                    /*align-items: baseline;*/
                    /*
                    stretch(拉伸对齐/等高对齐):
                    让所有的伸缩项的高度变为侧轴的高度
                    注意点:
                    如果需要设置为拉伸对齐, 那么伸缩项不能设置高度
                    如果伸缩项设置了高度, 那么拉伸对齐就会失效
                    */
                    align-items: stretch;</code>
                <br><code> /*
                如果在伸缩容器中通过 align-items: 来控制伸缩项的对齐方式, 是一次性控制所有伸缩项的对齐方式
                如果想单独的控制某一个伸缩项在侧轴上的对齐方式, 那么需要将控制对齐方式的属性写到伸缩项中
                align-items: 写到伸缩容器中 / 控制所有伸缩项
                align-self: 写到伸缩项中 / 控制编写对应代码的那个伸缩项
                align-self: 的取值和align-items:的取值是一样的, 只是控制的范围和书写的位置不同而已
                */</code>
                <br><h3>主轴永远垂直于侧轴</h3>
                <br><h3>换行与换行对齐问题</h3>
                <code>display: flex;
                    /*
                    1.默认情况下如果伸缩容器的一行放不下所有的伸缩项, 那么系统会自动等比压缩所有的伸缩项
                    2.在伸缩容器中有一个叫做flex-wrap属性, 专门用于控制放不下是否需要换行的
                    默认的取值: flex-wrap 不换行
                    wrap: 放不下就换行 而不是等比压缩
                    wrap-reverse: 放不下就换行 , 以行为单位进行反转
                    */
                    /*flex-wrap: nowrap;*/
                    /*flex-wrap: wrap;*/
                    /*flex-wrap: wrap-reverse;*/

                    flex-wrap: wrap;
                    /*
                    在伸缩容器中有一个叫做align-content的属性, 是专门用于设置换行之后的对齐方式的
                    注意点: 只有伸缩项发生了换行这个属性才有效
                    flex-start: 换行之后和侧轴的起点对齐, 一行接一行
                    flex-end: 换行之后和侧轴的终点对齐, 将所有换行之后的内容当做一个整体来操作
                    center: 换行之后和侧轴的中点对齐
                    space-between: 换行之后在侧轴上两端对齐
                    space-around: 换行之后在侧轴上环绕对齐
                    stretch: 以行为单位进行拉伸, 拉伸的部分以空白填充, 保证拉伸之后所有的行加起来能够填满侧轴
                    */
                    /*align-content: flex-start;*/
                    /*align-content: flex-end;*/
                    /*align-content: center;*/
                    /*align-content: space-between;*/
                    /*align-content: space-around;*/
                    align-content: stretch;</code>
                <br><h3>伸缩项排序问题</h3>
                <code> 默认情况下每一个伸缩项都有一个order属性, 用于决定排序的先后顺序
                    默认情况下所有伸缩项的order属性的取值都是0
                    我们可以通过修改order属性的取值来实现伸缩项的排序
                    order排序的规则: 从小到大的排序, 越小的显示在越前面, 越大的显示在越后面</code>
                <br><h3>伸缩项扩充</h3>
                <code>       ul>li:nth-child(1){
                    /*
                    在伸缩项中有一个flex-grow属性, 用于控制当所有伸缩项的宽度总和小于伸缩容器宽度的时候如何扩充自己, 以便于所有伸缩项宽度的总和能够填满整个伸缩容器
                    默认情况下flex-grow的取值是0, 表示我们设置的宽度是多少就按照多少来显示, 不进行任何的扩充
                    注意点:
                    只有当所有伸缩项的宽度总和小于伸缩容器宽度的时候flex-grow这个属性才有效

                    flex-grow缩小的公式
                    1.利用伸缩容器宽度 - 所有伸缩项的宽度 = 剩余空间
                    600 - 300 = 300
                    2.利用剩余空间 / 所有需要扩充份数的总和 = 每一份的大小
                    300 / (1 + 4 + 8) = 23.07
                    3.利用当前伸缩项的宽度 + 需要的份数的宽度
                    第一个伸缩项 = 100 + (1 * 23.07) = 123.07
                    第二个伸缩项 = 100 + (4 * 23.07) = 192.28
                    第三个伸缩项 = 100 + (8 * 23.07) = 284.56
                    */
                    flex-grow: 1 or 2 or 4 or ...;
                    }</code>
                <br><h3>伸缩项缩小</h3>
                <code>ul>li:nth-child(1){
                    /*
                    在伸缩项中有一个flex-shrink属性, 用于控制当所有伸缩项的宽度总和大于伸缩容器宽度的时候如何缩小自己, 以便于所有伸缩项宽度的总和能够填满整个伸缩容器
                    默认情况下flex-shrink的取值是1, 表示当所有伸缩项宽度的总和大于伸缩容器宽度的时候等比缩小自己
                    注意点:
                    只有当所有伸缩项的宽度总和大于伸缩容器宽度的时候flex-shrink这个属性才有效


                    flex-shrink扩充的公式
                    1.利用所有伸缩项的宽度总和 - 伸缩容器宽度 = 溢出的宽度
                    900 - 600 = 300
                    2.计算权重值
                    利用每一个伸缩项需要的份数 * 当前伸缩项的宽度 然后再相加
                    1 * 300 + 4 * 300 + 8 * 300 = 3900
                    3.计算每个伸缩项需要缩小的范围
                    溢出的宽度 * 当前伸缩项的宽度 * 当前伸缩项需要的份数 / 权重值
                    300 * 300 * 1 / 3900 = 23.07
                    第一个伸缩项宽度 = 300 - 23.07 = 276.9
                    300 * 300 * 4 / 3900 = 92.3
                    第二个伸缩项宽度 = 300 - 92.3 = 207.6
                    */
                    flex-shrink: 1;
                    }</code>
                <br>
                1.如果没有指定flex-grow属性, 或者flex-grow:的值是0, 那么当前的伸缩项不会被扩充
                2.如果flex-shrink的值是0, 那么当前的伸缩项不会被缩小
                3. 注意点
                前面所写的注释都是说宽度扩充或者宽度缩小, 但是这种说法是不严谨的
                也有可能扩充和缩小的是高度, 到底是宽度还是高度是由主轴决定的, 扩充和缩小的是主轴方向上的值
                也就是说如果主轴是水平方向的, 那么扩充和缩小的就是宽度
                也就是说如果主轴是垂直方向的, 那么扩充和缩小的就是高度
                <br><h3>连写</h3><code>       ul>li:nth-child(1){
                /*
                flex: 扩充 缩小 宽度;
                flex默认值
                flex: 0 1 auto;
                */
                flex: 0 1 100px;
                }</code>

            </div>
        </div>
    </div>
    <div class="card">
        <div class="card_title">50. 编写网站步骤</div>
        <div class="card_content">
            <div><code>
                1.新建站点文件夹
                1.1文件夹名称不能是中文
                1.2里面至少应该包含css/js/images三个子文件夹
                1.3里面至少应该包含index.html文件

                2.设置favorites icon网页图标
                显示在网页选项卡和收藏夹中的图标, 我们称之为favicon
                2.1生成网页图标
                搜索ico图标生成--上传图标--下载生成好的图标
                2.2放到站点目录根目录下
                2.3在head标签中间添加
                《link rel="shortcut icon" href="favicon.ico"  type="image/x-icon"/》

                3.添加网站优化三大标签
                3.1网页title标题
                - title是网页中第一重要的标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。
                - 标题长度: Google 35个中文, baidu 28个中文
                - 格式: 网站名（产品名）- 网站的介绍
                - 特点: 越先出现的词语, 权重越高

                3.2Keywords 关键字
                Keywords是页面关键词，是搜索引擎重点关注点之一。
                - Keywords应该限制在6～8个关键词左右，电商类网站可以多几个。

                《meta name="keyword" content="苏宁易购网上商城,苏宁电器,Suning,手机,电脑,冰箱,洗衣机,相机,数码,家居用品,鞋帽,化妆品,母婴用品,图书,食品,正品行货" /》

                3.3Description网站说明
                对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的

                - 补充在 title  和 keywords  中未能充分表述的说明.
                - 字符数含空格在内不要超过 120  个汉字
                - 描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击

                《meta name="description" content="苏宁易购-综合网上购物平台，商品涵盖家电、手机、电脑、超市、母婴、服装、百货、海外购等品类。送货更准时、价格更超值、上新货更快，正品行货、全国联保、可门店自提，全网更低价，让您放心去喜欢！" />
                --》


                4.导入CSS Rest 类库, 将所有的浏览器的自带样式重置掉，保持各浏览器渲染的一致性
                4.1reset.css
                无论是否有用, 一律清零

                4.2normalize.css
                - 保护有用的浏览器默认样式而不是完全去掉它们
                - 一般化的样式：为大部分HTML元素提供
                - 修复浏览器自身的bug并保证各浏览器的一致性
                - 优化CSS可用性：用一些小技巧
                - 解释代码：用注释和详细的文档来
                - https://github.com/necolas/normalize.css/


                5.设置全局通用字体行高
                font: 12px/1.5em "Microsoft Yahei",tahoma,arial,"Hiragino Sans GB";
                color: #999;
                background: #f2f2f2;

                6.值得思考的问题, 优雅降级和渐进增强
                6.1渐进增强
                针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验

                6.2优雅降级
                一开始就在高级浏览器上构建完整的功能，然后再针对低版本浏览器进行兼容

                6.3个人建议:
                - 现在微软都抛弃了ie浏览器转而支持 edge了，所以我们很多情况下没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题
                - 修补时现在最常见的做法就是为低版本浏览器 单独制作一个跳转页面

                            </code>

                            </div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title">51. 媒体查询</div>
                        <div class="card_content">
                            <div><code>《style》
                                *{
                                    margin: 0;
                                    padding: 0;
                                }
                                /*
                                div{
                                    width: 500px;
                                    height: 500px;
                                    background: red;
                                }
                                */

                                /*如果当前的网页是显示在电脑or平板or手机上的, 并且当前浏览器的宽度是大于等于1200px的, 那么就执行后面大括号中的代码*/
                                @media screen and (min-width: 1200px){
                                    div{
                                        width: 500px;
                                        height: 500px;
                                        background: red;
                                    }
                                }
                                /*如果当前的网页是显示在电脑or平板or手机上的, 并且当前浏览器的宽度是小于等于1199px的, 那么就执行后面大括号中的代码*/
                                @media screen and (max-width: 1199px){
                                    div{
                                        width: 300px;
                                        height: 300px;
                                        background: green;
                                    }
                                }
                                /*如果当前的网页是显示在电脑or平板or手机上的, 并且当前浏览器的宽度是小于等于768px的, 那么就执行后面大括号中的代码*/
                                @media screen and (max-width: 768px){
                                    div{
                                        width: 100px;
                                        height: 100px;
                                        background: blue;
                                    }
                                }
                            《/style》</code><br>
                                1.什么是媒体查询?
                                媒体查询就是获取到当前浏览器的宽度之后, 根据不同的宽度设置元素不同的样式

                                2.媒体查询的注意点
                                由于媒体查询需要根据不同的浏览器宽度调整元素的样式, 所以不适合用于比较复杂的网页

                                3.媒体查询的格式
                                在这里的media可以理解为英文的if(如果)
                                @media 条件{} 含义: 如果条件满足, 那么就执行后面{}中的代码
                                3.1内联格式: @media 条件{}
                                3.2外链格式: 《link rel="stylesheet" href="css/xxx.css" media="条件"》
                                <br><code>
                                    <!--
    1.在企业开发中, 如果需要分别给电脑/平板/手机分别设置样式, 那么我们会将电脑的样式写在前面, 平板的样式写在电脑的后面, 手机的样式写在平板的后面
    2.在企业开发中媒体查询中指定的宽度不是固定的, 指定的宽度是根据自己企业的需求来指定的, 并没有一个固定的值代表电脑的, 也没有一个固定的值代表平板的, 也没有一个固定的值代表手机的
    -->
                                    《link rel="stylesheet" href="媒体查询CSS/index-pc.css" media="screen and (min-width: 1200px)"》
                                    《link rel="stylesheet" href="媒体查询CSS/index-pad.css" media="screen and (max-width: 1199px)"》
                                    《link rel="stylesheet" href="媒体查询CSS/index-phone.css" media="screen and (max-width: 768px)"》
                                </code>
                                <br>
                                1.如果给电脑的CSS添加条件， 那么在平板和手机上所有的样式都会效果， 那么如果平板和手机上有和电脑上相同的样式也不能复用
                                2.所有我们不要给电脑的CSS添加条件， 这样无论浏览器的宽度是多少， 电脑的CSS文件都会被执行， 我们只需要在平板或者手机对应的CSS文件中通过相同的选择器覆盖掉不同的样式即可
                                3.降低了代码的冗余

                                4.企业开发中编写响应式网站的步骤
                                4.1编写电脑版本的网页
                                4.2编写平板版本的网页， 通过相同的选择器覆盖掉不同的样式
                                4.3编写手机版本的网页， 通过相同的选择器覆盖掉不同的样式
                                -->
                                《link rel="stylesheet" href="css/index.css"》
                                《link rel="stylesheet" href="css/index-pad.css" media="screen and (max-width: 1199px)"》
                                《link rel="stylesheet" href="css/index-phone.css"  media="screen and (max-width: 768px)"》
                            </div>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card_title"></div>
                        <div class="card_content">
                            <p>

                            </p>
                            <code>

                            </code>
                        </div>
                    </div>





















                </div>
                </body>
                </html>